----8/11/2018----
L'attuale versione del programma contiene alcune classi e la funzione test.C in cui è presente una buona idea di come deve funzionare la parte di simulazione dell'evento. Per adesso si simula un singolo evento e poi se ne aggiungeranno altri. La parte di ricostruzione non è ancora stata affrontata.

Macros:
-classcomplier.C: non deve essere compilata e serve a compilare tutte le classi utilizzate dal programma principale. È stata scritta seguendo le direttive di Masera e funziona 

-Event.cxx con relativo header file Event.h: contiene 4 data members che sono le coordinate del vertice primario e la molteciplità dell'evento. Il default constructor della classe inizializza tutti i data memebrs a "0". Il costruttore standard, invece, inizializza le coordinate del vertice con dei numeri casuali estratti da distribuzioni gaussiane con valori dati. La molteplicità è inizializzata ad un valore casuale estratto dalla distribuzione contenuta nel file "kinem.root". Le member functions sono 4 getter e servono a "gettare" le coordinate del vertice e la molteplicità dell'evento.

-Hit.cxx con relativo header file Hit.h: contiene 3 data members che sono le coordinate del punto di intersezione della particella con la beam pipe o con i rivelatori. Il default constructor inizalizza tutti i data members a "0". Il costruttore standard, invece, inizializza le coordinate del punto di intersezione con i valori che vengono calcolati tramite un' altra macro che vedremo in seguito. Le member functions sono i getter delle 3 cooridnate 

-Layer.cxx con relativo header file Layer.h: contiene 4 data members che sono, in ordine: width dell'apparato (27 cm), raggio (che dipende dal pezzo dell'apaprato che sto considerando), thickness (che anche dipende da cosa sto considerando) e in ultimo l'RMS usata nello scattering multiplo. Default constructor inizializza tutto a zero mentre lo standard inizializza a valori definti dall'utente. Le member functions sono i soliti getters

-Particle.cxx con relativo header file Particle.h: contiene 3 data members che sono i valori generati di theta, phi e la pseudorapidità della particella. Il default constructor inizalizza tutti i data members a "0". Il costruttore standard, invece, inizializza le coordinate del punto di intersezione con i valori che vengono calcolati tramite un' altra macro che vedremo in seguito. Le member functions sono i getter delle 2 coordinate polari e la pseudorapidità; quest'ultima è presa come un valore casuale da una distribuzione assegnata nel file "kinem.root". È presente anche la member function rotate che viene utilizzata nello scattering multiplo. Prende come argomento una variabile chiamata RMS che viene calcolata con la formula del multple scattering ed è l'RMS della distribuzione gaussiana dopo il multiple scattering. Nello spazio devo moltiplicare per 1/sqrt(2). L'angolo phi, invece, viene estratto a caso da 0 a 2pi. La matrice di rotazione è calcoalta secondo le formule di masera e fornisce le componenti del vettore che descrive la direzione della particella dopo lo scattering nel sistema di riferimento del laboratorio  

-Tools.cxx con relativo header file Tools.h: non una vera e propria classe, è più che altro una macro che contiene una funzione che viene utilizzata per calcolare l'intersezione delle particelle generate con i vari componenti del rivelatore. La funzione fa diverse cose: usando le formule date da Masera si calcola il punto di intersezione. Sostanzialmente si scrivono le rette con la formula parametrica usando i coseni direttori calcolati tramite i theta e phi generati casualmente. Usa poi l'equazioni di un cilindro e tramite un po' di passaggi trovo le intersezioni. Ricavo in pratica due valori di t (il parametro) e poi calcolo i valori di x, y e z usando quel valore di t che ho trovato prima risolvedno l'equazione di secondo grado. Attenzione solo al fatto che devo ritornare un array e questo non posso farlo in modo diretto in c++. Devo quindi fare una funzione che ritorni un puntatore, in particolare è il puntatore al primo elemento dell'array. Nel main in cui uso la funzione allora devo de-referenziare il pointer per poterlo usare. 
